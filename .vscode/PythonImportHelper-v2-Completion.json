[
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "style",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "style",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pca",
        "importPath": "Analytics.PCA.pca",
        "description": "Analytics.PCA.pca",
        "isExtraImport": true,
        "detail": "Analytics.PCA.pca",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "isExtraImport": true,
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "forecasts",
        "importPath": "Analytics.Forecasts",
        "description": "Analytics.Forecasts",
        "isExtraImport": true,
        "detail": "Analytics.Forecasts",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "Analytics.clustering.kmeans",
        "description": "Analytics.clustering.kmeans",
        "isExtraImport": true,
        "detail": "Analytics.clustering.kmeans",
        "documentation": {}
    },
    {
        "label": "KPrototypes",
        "importPath": "Analytics.clustering.kprototypes",
        "description": "Analytics.clustering.kprototypes",
        "isExtraImport": true,
        "detail": "Analytics.clustering.kprototypes",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "kind": 6,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "class KMeans():\n  \"\"\"\n    Inicializa un nuevo objeto de tipo KMeans \n    param: k - número de clusters\n    param: max_iter - número máximo de iteraciones\n    pre: k esté definida\n    post: se crea un nuevo objeto de tipo Kmeans\n  \"\"\"\n  def __init__(self, k, max_iter=300, random_state=19):\n    self.k = k ",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "data1",
        "kind": 5,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "data1 = pd.read_csv('Analytics/clustering/kmeans/datasets/buddymove_holidayiq.csv', header = None)\n#plt.scatter(data1[0].values, data1[1].values)\n'''print(data1.tail())'''\nnormalized_df = ((data1-data1.mean())/data1.std()).to_numpy()\n'''\nprint('Uno\\n')\nprint(normalized_df)\n'''\n#Normalizacion de datos, para que se conserve el tipo de dato\ndf_scaled = StandardScaler()",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "normalized_df",
        "kind": 5,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "normalized_df = ((data1-data1.mean())/data1.std()).to_numpy()\n'''\nprint('Uno\\n')\nprint(normalized_df)\n'''\n#Normalizacion de datos, para que se conserve el tipo de dato\ndf_scaled = StandardScaler()\ndf_scaled = pd.DataFrame(df_scaled.fit_transform(data1),columns  = data1.columns )\n'''print(df_scaled.tail())'''\n\"\"\"Acontinuecion se realizara el proceso para escoger la cantidad adecuada de clusters\"\"\"",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "df_scaled",
        "kind": 5,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "df_scaled = StandardScaler()\ndf_scaled = pd.DataFrame(df_scaled.fit_transform(data1),columns  = data1.columns )\n'''print(df_scaled.tail())'''\n\"\"\"Acontinuecion se realizara el proceso para escoger la cantidad adecuada de clusters\"\"\"\n#Se crea un arreglo donde se guardaran la distorcion con la cantidad de clusters\n#En terminos matematicos, se guardara la suma de las distancias al cuadrados de todos los puntos a su centro asignado\ndistortions = []\nK = range(1,6)\nclass KMeans():\n  \"\"\"",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "df_scaled",
        "kind": 5,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "df_scaled = pd.DataFrame(df_scaled.fit_transform(data1),columns  = data1.columns )\n'''print(df_scaled.tail())'''\n\"\"\"Acontinuecion se realizara el proceso para escoger la cantidad adecuada de clusters\"\"\"\n#Se crea un arreglo donde se guardaran la distorcion con la cantidad de clusters\n#En terminos matematicos, se guardara la suma de las distancias al cuadrados de todos los puntos a su centro asignado\ndistortions = []\nK = range(1,6)\nclass KMeans():\n  \"\"\"\n    Inicializa un nuevo objeto de tipo KMeans ",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "distortions",
        "kind": 5,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "distortions = []\nK = range(1,6)\nclass KMeans():\n  \"\"\"\n    Inicializa un nuevo objeto de tipo KMeans \n    param: k - número de clusters\n    param: max_iter - número máximo de iteraciones\n    pre: k esté definida\n    post: se crea un nuevo objeto de tipo Kmeans\n  \"\"\"",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "K",
        "kind": 5,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "K = range(1,6)\nclass KMeans():\n  \"\"\"\n    Inicializa un nuevo objeto de tipo KMeans \n    param: k - número de clusters\n    param: max_iter - número máximo de iteraciones\n    pre: k esté definida\n    post: se crea un nuevo objeto de tipo Kmeans\n  \"\"\"\n  def __init__(self, k, max_iter=300, random_state=19):",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "red",
        "kind": 5,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "red = pca(2)\nfor k in  K:\n  clf = KMeans(k = k)\n  df_compress = red.fit(df_scaled)\n  clf.fit(df_compress)\n  for i in range(50):\n    clf.step(clf.data)\n  distortions.append(clf.distortion)\nprint(len(distortions))\nplt.figure(figsize=(12,6))",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "colors = 10*[\"g\",\"r\",\"c\",\"b\",\"k\",\"y\",\"m\"]\nfor classification in clf.clasified_data:\n    color = colors[classification]\n    for featureset in clf.clasified_data[classification]:\n        plt.scatter(featureset[0], featureset[1], color=color, s=80, linewidths=2)\n#print(clf.centroids)\nfor centroid in clf.real_crentroids:\n  plt.scatter(clf.real_crentroids[centroid][0], clf.real_crentroids[centroid][1],\n    marker=\"x\", color=\"k\", s=150, linewidths=5)\nplt.show()",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "KPrototypes",
        "kind": 6,
        "importPath": "Analytics.clustering.kprototypes.KPrototypes",
        "description": "Analytics.clustering.kprototypes.KPrototypes",
        "peekOfCode": "class KPrototypes(KMeans):\n  \"\"\"\n    Inicializa un nuevo objeto de tipo KMeans \n    param: k - número de clusters\n    param: max_iter - número máximo de iteraciones\n    pre: k esté definida\n    post: se crea un nuevo objeto de tipo Kmeans\n  \"\"\"\n  def __init__(self, k, cat, plot_var, max_iter=300):\n    self.k = k ",
        "detail": "Analytics.clustering.kprototypes.KPrototypes",
        "documentation": {}
    },
    {
        "label": "data1",
        "kind": 5,
        "importPath": "Analytics.clustering.kprototypes.KPrototypes",
        "description": "Analytics.clustering.kprototypes.KPrototypes",
        "peekOfCode": "data1 = pd.read_csv('Analytics/clustering/kprototypes/datasets/super.csv', sep=',')  \nprint(data1)\nnormalized_df = ((data1-data1.mean())/data1.std()).to_numpy()\nclass KPrototypes(KMeans):\n  \"\"\"\n    Inicializa un nuevo objeto de tipo KMeans \n    param: k - número de clusters\n    param: max_iter - número máximo de iteraciones\n    pre: k esté definida\n    post: se crea un nuevo objeto de tipo Kmeans",
        "detail": "Analytics.clustering.kprototypes.KPrototypes",
        "documentation": {}
    },
    {
        "label": "normalized_df",
        "kind": 5,
        "importPath": "Analytics.clustering.kprototypes.KPrototypes",
        "description": "Analytics.clustering.kprototypes.KPrototypes",
        "peekOfCode": "normalized_df = ((data1-data1.mean())/data1.std()).to_numpy()\nclass KPrototypes(KMeans):\n  \"\"\"\n    Inicializa un nuevo objeto de tipo KMeans \n    param: k - número de clusters\n    param: max_iter - número máximo de iteraciones\n    pre: k esté definida\n    post: se crea un nuevo objeto de tipo Kmeans\n  \"\"\"\n  def __init__(self, k, cat, plot_var, max_iter=300):",
        "detail": "Analytics.clustering.kprototypes.KPrototypes",
        "documentation": {}
    },
    {
        "label": "clf",
        "kind": 5,
        "importPath": "Analytics.clustering.kprototypes.KPrototypes",
        "description": "Analytics.clustering.kprototypes.KPrototypes",
        "peekOfCode": "clf = KPrototypes(cat = [0, 1], plot_var= [3,4], k = 6)\nclf.fit(normalized_df)\nfor centroid in clf.centroids:\n    plt.scatter(clf.centroids[centroid][0], clf.centroids[centroid][1],\n                marker=\"x\", color=\"k\", s=150, linewidths=5)\ncolors = 10*[\"g\",\"r\",\"c\",\"b\",\"k\"]\nfor classification in clf.clasified_data:\n    color = colors[classification]\n    for featureset in clf.clasified_data[classification]:\n        plt.scatter(featureset[clf.plot_var[0]], featureset[clf.plot_var[1]], color=color, s=80, linewidths=2)",
        "detail": "Analytics.clustering.kprototypes.KPrototypes",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "Analytics.clustering.kprototypes.KPrototypes",
        "description": "Analytics.clustering.kprototypes.KPrototypes",
        "peekOfCode": "colors = 10*[\"g\",\"r\",\"c\",\"b\",\"k\"]\nfor classification in clf.clasified_data:\n    color = colors[classification]\n    for featureset in clf.clasified_data[classification]:\n        plt.scatter(featureset[clf.plot_var[0]], featureset[clf.plot_var[1]], color=color, s=80, linewidths=2)\nplt.show()\n\"\"\"",
        "detail": "Analytics.clustering.kprototypes.KPrototypes",
        "documentation": {}
    },
    {
        "label": "HelloWorld",
        "kind": 2,
        "importPath": "Analytics.Forecasts.forecasts",
        "description": "Analytics.Forecasts.forecasts",
        "peekOfCode": "def HelloWorld():\n    return \"Hello, World!\"",
        "detail": "Analytics.Forecasts.forecasts",
        "documentation": {}
    },
    {
        "label": "pca",
        "kind": 6,
        "importPath": "Analytics.PCA.Pca",
        "description": "Analytics.PCA.Pca",
        "peekOfCode": "class pca():\n    def __init__(self, n):\n        self.n = n\n    def fit(self, data):\n        #Calculo de la matrix de convarinza\n        cov_mat = np.cov(data.T)\n        '''print('NumPy covariance matrix: \\n%s' %cov_mat)'''\n        #Calculo de los eigenvector y eigenvalues\n        eigen_vals, eigen_vecs = np.linalg.eig(cov_mat)\n        '''",
        "detail": "Analytics.PCA.Pca",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "run",
        "description": "run",
        "peekOfCode": "app = Flask(__name__)\napp.add_url_rule('/', view_func=forecasts.HelloWorld)\n\"\"\"\napp.add_url_rule('/', view_func=KMeans.)\napp.add_url_rule('/', view_func=KPrototypes.)\n\"\"\"",
        "detail": "run",
        "documentation": {}
    }
]